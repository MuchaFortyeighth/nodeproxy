package com.mix.service;

import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.mix.entity.dto.Vulnerability;
import com.mix.entity.dto.VulnerabilityAttackLog;
import com.mix.mapper.DefiContractMapper;
import com.mix.mapper.VulnerabilityAttackLogMapper;
import com.mix.mapper.VulnerabilityMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class VulnerabilityService {
    @Autowired
    private VulnerabilityMapper vulnerabilityMapper;

    @Autowired
    private DefiContractMapper defiContractMapper;

    @Autowired
    private VulnerabilityAttackLogMapper vulnerabilityAttackLogMapper;

    public List<Vulnerability> getVulnerabilityList() {
        // 查询已有的漏洞列表
        List<Vulnerability> originalList = vulnerabilityMapper.queryVulnerabilityList();

        // 补充文档中的其他漏洞类型和示例合约
        List<Vulnerability> additionalList = new ArrayList<>();

        // 重入漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("重入漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("ReentrantWallet", generateFakeContractAddress(), "钱包合约存在重入漏洞，攻击者利用重复调用导致资金损失。", "重入漏洞"));
        additionalList.add(createVulnerability("NestedDAO", generateFakeContractAddress(), "复杂DAO合约中存在重入漏洞，导致递归提款。", "重入漏洞"));
        additionalList.add(createVulnerability("RecursiveBank", generateFakeContractAddress(), "银行合约的提款逻辑存在重入漏洞。", "重入漏洞"));
        additionalList.add(createVulnerability("FallbackAttack", generateFakeContractAddress(), "攻击者利用 fallback 函数触发重入攻击。", "重入漏洞"));

        // 整数溢出漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("整数溢出漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("InfiniteToken", generateFakeContractAddress(), "整数溢出导致代币铸造无限量，破坏经济模型。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("ArithmeticBugToken", generateFakeContractAddress(), "代币合约中算术运算未检查溢出，导致代币生成异常。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("OverflowVault", generateFakeContractAddress(), "代币存储合约存在整数溢出漏洞，攻击者可提取超额资产。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("BatchOverflowToken", generateFakeContractAddress(), "批量转账功能中存在溢出漏洞，导致代币异常增发。", "整数溢出漏洞"));

        // 访问控制漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("访问控制漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("AdminlessToken", generateFakeContractAddress(), "缺少管理员权限验证，攻击者可直接调用关键函数。", "访问控制漏洞"));
        additionalList.add(createVulnerability("PermissionlessContract", generateFakeContractAddress(), "关键操作未限制访问，导致权限被滥用。", "访问控制漏洞"));
        additionalList.add(createVulnerability("MintWithoutOwner", generateFakeContractAddress(), "攻击者可通过铸造函数生成未授权的代币。", "访问控制漏洞"));
        additionalList.add(createVulnerability("UnauthorizedApproval", generateFakeContractAddress(), "合约中授权逻辑缺陷导致攻击者可以批准任意地址。", "访问控制漏洞"));

        // 拒绝服务漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("拒绝服务漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("GasLimitDoS", generateFakeContractAddress(), "攻击者通过耗尽 gas 资源使合约功能不可用。", "拒绝服务漏洞"));
        additionalList.add(createVulnerability("OverloadContract", generateFakeContractAddress(), "合约设计问题导致大量用户请求造成拒绝服务。", "拒绝服务漏洞"));
        additionalList.add(createVulnerability("StorageFlood", generateFakeContractAddress(), "恶意用户通过填满存储导致合约无法操作。", "拒绝服务漏洞"));
        additionalList.add(createVulnerability("LoopExhaustion", generateFakeContractAddress(), "攻击者利用合约循环消耗资源，导致合约失效。", "拒绝服务漏洞"));

        // 短地址漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("短地址漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("TruncatedToken", generateFakeContractAddress(), "短地址输入导致代币数量被操控。", "短地址漏洞"));
        additionalList.add(createVulnerability("PaddingIssueContract", generateFakeContractAddress(), "输入地址未正确校验，导致地址截断漏洞。", "短地址漏洞"));
        additionalList.add(createVulnerability("ShortAddressAttack", generateFakeContractAddress(), "攻击者通过短地址输入操控合约逻辑。", "短地址漏洞"));
        additionalList.add(createVulnerability("AddressLengthMismatch", generateFakeContractAddress(), "短地址漏洞导致合约解析错误。", "短地址漏洞"));

        // 时间依赖漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("时间依赖漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("TimestampReward", generateFakeContractAddress(), "奖励分发依赖区块时间，攻击者通过时间操控获利。", "时间依赖漏洞"));
        additionalList.add(createVulnerability("BlockDelayContract", generateFakeContractAddress(), "区块时间戳依赖导致攻击者通过延迟操控行为。", "时间依赖漏洞"));
        additionalList.add(createVulnerability("LotteryTimeManipulation", generateFakeContractAddress(), "彩票合约依赖时间戳分配奖励，攻击者操控时间获胜。", "时间依赖漏洞"));
        additionalList.add(createVulnerability("AuctionTimestamp", generateFakeContractAddress(), "拍卖合约时间依赖漏洞，攻击者操控拍卖时间段获利。", "时间依赖漏洞"));

        // 闪电贷漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("闪电贷漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("FlashLoanAbuse", generateFakeContractAddress(), "闪电贷操作存在漏洞，攻击者套利导致资金流失。", "闪电贷漏洞"));
        additionalList.add(createVulnerability("LiquidityDrain", generateFakeContractAddress(), "闪电贷合约未检查余额变化，攻击者提取资金。", "闪电贷漏洞"));
        additionalList.add(createVulnerability("FlashLoanCascade", generateFakeContractAddress(), "攻击者利用多次闪电贷操作操控市场价格。", "闪电贷漏洞"));
        additionalList.add(createVulnerability("LoanReentryExploit", generateFakeContractAddress(), "闪电贷逻辑中存在重入漏洞，攻击者通过回调函数操控逻辑。", "闪电贷漏洞"));

        // Owner漏洞与后门
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("Owner漏洞与后门")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("HiddenBackdoor", generateFakeContractAddress(), "存在后门函数，攻击者可直接控制合约。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("MisconfiguredAdmin", generateFakeContractAddress(), "管理员地址错误配置导致权限泄露。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("FakeOwnerSetup", generateFakeContractAddress(), "攻击者伪造管理员身份，获得合约控制权。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("UnauthorizedOwnership", generateFakeContractAddress(), "所有权转移逻辑缺陷，导致攻击者获取控制权。", "Owner漏洞与后门"));

        // 构造函数漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("构造函数漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("ConstructorOverride", generateFakeContractAddress(), "构造函数漏洞导致攻击者初始化时获取控制权。", "构造函数漏洞"));
        additionalList.add(createVulnerability("DeploymentHijack", generateFakeContractAddress(), "部署时存在逻辑缺陷，攻击者可篡改合约。", "构造函数漏洞"));
        additionalList.add(createVulnerability("InitializationBug", generateFakeContractAddress(), "初始化函数中存在漏洞，攻击者通过合约初始化获取权限。", "构造函数漏洞"));
        additionalList.add(createVulnerability("ConstructorAccessExploit", generateFakeContractAddress(), "攻击者利用构造函数访问逻辑劫持合约。", "构造函数漏洞"));

        // 合并列表：保留原有数据在前，补充数据在后，并确保按漏洞类型分组
//        originalList.addAll(groupByVulnerabilityType(additionalList));
        return additionalList;
    }

    private Vulnerability createVulnerability(String contractName, String contractAddress, String contractDescribe, String vulnerabilityType) {
        Vulnerability vulnerability = new Vulnerability();
        vulnerability.setContractName(contractName);
        vulnerability.setContractAddress(contractAddress);
        vulnerability.setContractDescribe(contractDescribe);
        vulnerability.setVulnerabilityType(vulnerabilityType);

        // 动态填充相关字段
        vulnerability.setSourceCode("合约源代码动态生成");
        vulnerability.setSourceCodeTree("动态生成的AST格式");
        vulnerability.setSourceCodeScanResult("动态生成的扫描结果");
        vulnerability.setAttackStep(new JSONObject()); // 示例，实际可根据需求填充
        return vulnerability;
    }

    private String generateFakeContractAddress() {
        return "0xfakeaddress";
    }

    private List<Vulnerability> groupByVulnerabilityType(List<Vulnerability> vulnerabilities) {
        // 根据漏洞类型分组
        return vulnerabilities.stream()
                .sorted(Comparator.comparing(Vulnerability::getVulnerabilityType))
                .collect(Collectors.toList());
    }

    public Vulnerability getVulnerabilityDetails(String contractAddress) {
        return vulnerabilityMapper.queryVulnerabilityDetails(contractAddress);
    }

    public Vulnerability getDefiContractVulnerabilityDetails(String contractAddress) {
        return defiContractMapper.queryVulnerabilityDetails(contractAddress);
    }

    public JSONObject getAttackStep(String contractAddress, String attackerAddress, String spendAmount) {
        String attackStep = vulnerabilityMapper.queryAttackStep(contractAddress);
        if (attackStep == null) {
            throw new IllegalArgumentException("No data found for the given contract address.");
        }

        // 替换 0xAttackerAddress123 的值
        attackStep = attackStep.replace("0xAttackerAddress123", attackerAddress);
//        attackStep = attackStep.replace("\"balance\"", spendAmount);

        Vulnerability vulnerability = vulnerabilityMapper.queryVulnerabilityBaseInfo(contractAddress);
        if (vulnerability != null) {
            // 创建日志对象
            VulnerabilityAttackLog attackLog = new VulnerabilityAttackLog();
            attackLog.setContractName(vulnerability.getContractName());
            attackLog.setContractAddress(contractAddress);
            attackLog.setAttackerAddress(attackerAddress);
            attackLog.setAttackTime(LocalDateTime.now());
            attackLog.setVulnerabilityType(vulnerability.getVulnerabilityType());

            // 插入日志
            vulnerabilityAttackLogMapper.insert(attackLog);
        }

        // 转换为 JSONObject 返回
        JSONObject jsonObject = JSONObject.parseObject(attackStep);
        jsonObject.put("attackTime",LocalDateTime.now());
        return jsonObject;
    }

    public IPage<VulnerabilityAttackLog> getPaginatedLogs(int page, int size) {
        // 构造分页对象
        Page<VulnerabilityAttackLog> pagination = new Page<>(page, size);
        return vulnerabilityAttackLogMapper.queryPaginatedLogs(pagination);
    }

}
