package com.mix.service;

import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.mix.entity.dto.Vulnerability;
import com.mix.entity.dto.VulnerabilityAttackLog;
import com.mix.mapper.DefiContractMapper;
import com.mix.mapper.VulnerabilityAttackLogMapper;
import com.mix.mapper.VulnerabilityMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class VulnerabilityService {
    @Autowired
    private VulnerabilityMapper vulnerabilityMapper;

    @Autowired
    private DefiContractMapper defiContractMapper;

    @Autowired
    private VulnerabilityAttackLogMapper vulnerabilityAttackLogMapper;

    public List<Vulnerability> getVulnerabilityList() {
        // 查询已有的漏洞列表
        List<Vulnerability> originalList = vulnerabilityMapper.queryVulnerabilityList();

        // 补充文档中的其他漏洞类型和示例合约
        List<Vulnerability> additionalList = new ArrayList<>();

        // 重入漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("重入漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("Uniswap", generateFakeContractAddress(), "钱包合约存在重入漏洞，攻击者利用重复调用导致资金损失。", "重入漏洞"));
        additionalList.add(createVulnerability("The idols", generateFakeContractAddress(), "复杂DAO合约中存在重入漏洞，导致递归提款。", "重入漏洞"));
        additionalList.add(createVulnerability("ETH-imBTC", generateFakeContractAddress(), "银行合约的提款逻辑存在重入漏洞。", "重入漏洞"));
        additionalList.add(createVulnerability("MTokenERC777", generateFakeContractAddress(), "攻击者利用 fallback 函数触发重入攻击。", "重入漏洞"));

        // 整数溢出漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("整数溢出漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("InfiniteToken", generateFakeContractAddress(), "整数溢出导致代币铸造无限量，破坏经济模型。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("SMT", generateFakeContractAddress(), "代币合约中算术运算未检查溢出，导致代币生成异常。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("EthLendToken", generateFakeContractAddress(), "代币存储合约存在整数溢出漏洞，攻击者可提取超额资产。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("Legolas", generateFakeContractAddress(), "批量转账功能中存在溢出漏洞，导致代币异常增发。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("LGO", generateFakeContractAddress(), "该合约相当于一个代币分配协议，owner可以随意给其他用户分配代币", "整数溢出漏洞"));
        additionalList.add(createVulnerability("PKT", generateFakeContractAddress(), "PKT合约对应代币PKT Playkey Token，存在整数溢出漏洞合约为PKT。PKT合约中涉及漏洞的函数主要是mint()。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("MyAdvancedToken", generateFakeContractAddress(), "漏洞可以通过设置sellPrice（精心设计大数），代币以高价售出，并导致转账时发生整数溢出，从而转出极小的额度。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("MiniMeToken", generateFakeContractAddress(), "MiniMeToken合约对应代币LIGHT LIGHTCOIN。这是一个由减法运算而产生的整数下溢的实际案例。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("TokenERC20", generateFakeContractAddress(), "函数mintToken()，允许owner通过调用该函数，随意增加指定地址的代币额度。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("EncryptedToken", generateFakeContractAddress(), "EncryptedToken合约对应代币EUC。EUC是一款基于以太坊的数字货币，对应产品为Eucalyptus Eucalyptus 3.x。EncryptedToken合约的回退函数存在安全漏洞。攻击者通过将售价设置成较大值，导致回退函数中的数据溢出。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("ATL", generateFakeContractAddress(), " ATL合约对应代币ATL ATLANT Token。智能合约的mint()函数存在整数溢出漏洞。攻击者可利用该漏洞，将任意用户的余额设置成给定的值。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("BitcoinRed", generateFakeContractAddress(), "BitcoinRed合约对应代币BTCR Bitcoin Red。合约中函数distributeBTR()多处存在溢出漏洞。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("QTX Quartex", generateFakeContractAddress(), "合约代币QTX Quartex存在整数溢出漏洞，该漏洞于烧毁代币的函数burnWithDecimals()。当溢出发生时，烧毁代币值0，即假烧币攻击。", "整数溢出漏洞"));
        additionalList.add(createVulnerability("EDU", generateFakeContractAddress(), "EduCoin合约对应代币EDU EduCoinToken。EduCoin合约中transferFrom()函数的转账金额超出allowed的限制后，会发生溢出。", "整数溢出漏洞"));

        // 访问控制漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("访问控制漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("AURA", generateFakeContractAddress(), "AURA合约对应代币Aurora DAO。由于内部合约Owned的函数setOwner()未设置访问控制权限，导致任何用户都可以调用该函数，从而成为合约的owner。", "访问控制漏洞"));
        additionalList.add(createVulnerability("BitBook", generateFakeContractAddress(), "BitBook合约对应代币BBT BitBook。合约函数mint()没有标识访问控制权限，不仅如此，也没有限制调用者。", "访问控制漏洞"));
        additionalList.add(createVulnerability("BBT", generateFakeContractAddress(), "攻击者可通过铸造函数生成未授权的代币。", "访问控制漏洞"));
        additionalList.add(createVulnerability("Aurora DAO", generateFakeContractAddress(), "合约中授权逻辑缺陷导致攻击者可以批准任意地址。", "访问控制漏洞"));

        // 拒绝服务漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("拒绝服务漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("IntelligentTradingTechnologie", generateFakeContractAddress(), "IntelligentTradingTechnologie合约对应代币ITT Intelligent Trading Technologies。合约的转账函数transfer()既没有标识访问控制权限，也没有这设置返回值。", "拒绝服务漏洞"));
        additionalList.add(createVulnerability("SwftCoin", generateFakeContractAddress(), "SwftCoin合约对应代币SWFTC SwftCoin。合约函数transfer()既未标识访问控制权限，也未标识返回值。", "拒绝服务漏洞"));
        additionalList.add(createVulnerability("CDTToken", generateFakeContractAddress(), "CDTToken合约对应的代币是CDT CoinDash Token。CDTToken合约中transfer()函数未标识访问控制权限，也未标识返回值。", "拒绝服务漏洞"));
        additionalList.add(createVulnerability("LoopExhaustion", generateFakeContractAddress(), "攻击者利用合约循环消耗资源，导致合约失效。", "拒绝服务漏洞"));
        additionalList.add(createVulnerability("MintableToken", generateFakeContractAddress(), "MintableToken合约对应代币CCT Crystal Clear Token。合约函数transferFrom()不仅没有指定访问控制权限，也没有设置返回值。", "拒绝服务漏洞"));
        additionalList.add(createVulnerability("BNB", generateFakeContractAddress(), "BNB合约对应代币BNB。合约函数transfer()用于向目标地址传输代币，该函数没有指定返回值。", "拒绝服务漏洞"));

        // 短地址漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("短地址漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("UniswapV2Pair", generateFakeContractAddress(), "UniswapV2Pair合约对应代币UNI-V2 Uniswap V2，合约函数transfer()用于代币的转账，其访问控制权限为external，可以被外部合约调用。", "短地址漏洞"));
        additionalList.add(createVulnerability("Token", generateFakeContractAddress(), "Token合约对应代币USDT ERC-20。合约函数transfer()进行了简单的数值检验，但是，没有对地址的检验。", "短地址漏洞"));
        additionalList.add(createVulnerability("EduCoin", generateFakeContractAddress(), "合约EduCoin对应代币EDU EduCoinToken。合约中函数transferFrom()没有判断地址_to地址的长度，仅检验0x0地址。", "短地址漏洞"));
        additionalList.add(createVulnerability("BaseV1", generateFakeContractAddress(), "BaseV1合约对应代币DDDX。合约中函数transfer()中调用了_transfer()函数，实现代币的转账。", "短地址漏洞"));

        // 时间依赖漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("时间戳依赖漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("AAGToken", generateFakeContractAddress(), "合约AAGToken对应代币为AAG。合约函数proposeLosslessTurnOff()和executeLosslessTurnOff()中存在时间戳依赖。", "时间戳依赖漏洞"));
        additionalList.add(createVulnerability("EggToken", generateFakeContractAddress(), "EggToken合约对应代币Goose Golden Egg。其中，函数delegateBySig()中存在now时间参数的使用。", "时间戳依赖漏洞"));
        additionalList.add(createVulnerability("Honey", generateFakeContractAddress(), "Honey合约对应代币是HNY HONEY。合约中函数getSalesTax()用于计算出售给流动资金池的代笔销售税。", "时间戳依赖漏洞"));
        additionalList.add(createVulnerability("DadiToken", generateFakeContractAddress(), "DadiToken合约对应代币DADI。合约函数getRandom()通过block.number产生一个随机数。", "时间戳依赖漏洞"));

        // 闪电贷漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("闪电贷漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("HEALTH", generateFakeContractAddress(), "攻击者先用闪电贷获得40WBNB，然后，买入30565652 + 955176个HEALTH。其中，攻击者实际获得30565652个HEALTH，955176进入合约地址作为税费。Token对应代币HEALTH。", "闪电贷漏洞"));
        additionalList.add(createVulnerability("ETHpledge", generateFakeContractAddress(), "2022年6月6日Binance链上Discover智能合约遭到闪电贷攻击。\n" +
                "攻击者通过PancakeSwap闪电贷借款2100USD和19810USD。\n" +
                "攻击者将2000USD转移至ETHpledge合约。ETHpledge合约返回62,536 枚Discover。\n" +
                "将19,810USD归还闪电贷至BSC-USD-Discover。\n" +
                "将62,536Discover换取USD，获得16,336枚USD。\n" +
                "归还2,100闪电贷借款，将剩余的USD兑换为BNB，获利离场。\n", "闪电贷漏洞"));
        additionalList.add(createVulnerability("Discover", generateFakeContractAddress(), "攻击者利用多次闪电贷操作操控市场价格。", "闪电贷漏洞"));
        additionalList.add(createVulnerability("PancakeSwap", generateFakeContractAddress(), "闪电贷逻辑中存在重入漏洞，攻击者通过回调函数操控逻辑。", "闪电贷漏洞"));

        // Owner漏洞与后门
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("Owner漏洞与后门")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("TNBToken", generateFakeContractAddress(), "TNBToken合约对应代币TNB Time New Bank。合约函数destroyTokens()用于销毁_owner地址的_amount数量的代币。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("IBTCToken", generateFakeContractAddress(), "IBTCToken合约对应代币IBTC。合约函数destroyIBTCToken()用于销毁代币IBTCToken。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("sacToken", generateFakeContractAddress(), "sacToken合约对应的代币是SAC Smart Application Chain。合约函数melt()用于销毁代币的Token。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("HxroTokenContract", generateFakeContractAddress(), "HxroTokenContract合约对应代币HXRO。合约函数sweep()用于从_from地址向_to地址转发额度为_value的代币。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("TokenERC20", generateFakeContractAddress(), "在这个漏洞中，owner能够随意增加给定地址的代币额度。不仅如此，owner还可以从一个地址扣除代币额度。这是因为在合约部署时，owner被设定为合约部署者的地址，也只有owner可以修改owner账号地址。如此一来，这个漏洞就只能被owner调用。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("MyAdvancedToken", generateFakeContractAddress(), "函数setPrices()只能被owner调用。这样，owner就可以根据需要，设置一个高的卖出价格，以及一个低的买入价格。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("LadaToken", generateFakeContractAddress(), "LadaToken合约对应代币LDT LadaToken。合约中mintToken()函数，不仅存在溢出漏洞，也为owner提供了后门。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("AssetToken", generateFakeContractAddress(), "AssetToken合约对应代币vl coin(vlcn)。合约中owner能够随意增加给定地址的代币额度。不仅如此，owner还可以从一个地址扣除代币额度。", "Owner漏洞与后门"));
        additionalList.add(createVulnerability("LadaToken", generateFakeContractAddress(), "LadaToken合约对应代币LadaToken(LDT)。合约函数mintToken()的访问控制权限为onlyOwner、public，允许owner在外部调用该函数。", "Owner漏洞与后门"));

        // 构造函数漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("构造函数漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("MorphToken", generateFakeContractAddress(), "orphToken合约对应代币MORPH。MorphToken是Morpheus Network开发的合约。Morpheus Network期望通过智能合约为国际大型航运、海关、银行等建立全球性的、开放的供应链平台，以及集成的加密货币支付系统。", "构造函数漏洞"));
        additionalList.add(createVulnerability("TOGToken", generateFakeContractAddress(), "TOGToken合约对应代币0xb9D5C2548266428795fd8b1F12aedbdeb417fe54。合约在定义构造函数时，将保留字“constructor”写成了“Constructor”。", "构造函数漏洞"));
        additionalList.add(createVulnerability("ReaperCoin11", generateFakeContractAddress(), "ReaperCoin11对应代币未知。ReaperCoin11合约的构造函数名由于被写成了function Reaper11()。", "构造函数漏洞"));
        additionalList.add(createVulnerability("ConstructorAccessExploit", generateFakeContractAddress(), "攻击者利用构造函数访问逻辑劫持合约。", "构造函数漏洞"));

        // 跨合约调用漏洞
        for (Vulnerability vulnerability : originalList) {
            if(vulnerability.getVulnerabilityType().equals("跨合约调用漏洞")){
                additionalList.add(vulnerability);
            }
        }
        additionalList.add(createVulnerability("Pycoin", generateFakeContractAddress(), "Pycoin合约对应代币为Pyc Pycoin，其中的MintableBurnableERC827Token合约继承自ERC20合约，包含approve()、transfer()、transferFrom()、increaseApproval()和decreaseApproval()等多个函数，主要用于代币的转账额度授权、代币转账，以及代币转账额度的调整。", "跨合约调用漏洞"));
        additionalList.add(createVulnerability("SMT", generateFakeContractAddress(), "SMT合约对应代币名SMT SmartMesh Token。合约中approveAndCall()和approveAndCallcode()函数内部调用call()函数。", "跨合约调用漏洞"));
        additionalList.add(createVulnerability("NANJCOIN", generateFakeContractAddress(), "NANJCOIN合约对应代币NANJ NANJCOIN。合约函数transfer()的内部涉及到跨合约调用的call()。", "跨合约调用漏洞"));
        additionalList.add(createVulnerability("BerryToken", generateFakeContractAddress(), "BerryToken合约BerryToken对应代币BERRY Berry。合约函数transfer()和transferFrom()等多处涉及到call()函数调用。", "跨合约调用漏洞"));

        return additionalList;
    }

    private Vulnerability createVulnerability(String contractName, String contractAddress, String contractDescribe, String vulnerabilityType) {
        Vulnerability vulnerability = new Vulnerability();
        vulnerability.setContractName(contractName);
        vulnerability.setContractAddress(contractAddress);
        vulnerability.setContractDescribe(contractDescribe);
        vulnerability.setVulnerabilityType(vulnerabilityType);

        // 动态填充相关字段
        vulnerability.setSourceCode("合约源代码动态生成");
        vulnerability.setSourceCodeTree("动态生成的AST格式");
        vulnerability.setSourceCodeScanResult("动态生成的扫描结果");
        vulnerability.setAttackStep(new JSONObject()); // 示例，实际可根据需求填充
        return vulnerability;
    }

    private String generateFakeContractAddress() {
        return "0xfakeaddress";
    }

    private List<Vulnerability> groupByVulnerabilityType(List<Vulnerability> vulnerabilities) {
        // 根据漏洞类型分组
        return vulnerabilities.stream()
                .sorted(Comparator.comparing(Vulnerability::getVulnerabilityType))
                .collect(Collectors.toList());
    }

    public Vulnerability getVulnerabilityDetails(String contractAddress) {
        return vulnerabilityMapper.queryVulnerabilityDetails(contractAddress);
    }

    public Vulnerability getDefiContractVulnerabilityDetails(String contractAddress) {
        return defiContractMapper.queryVulnerabilityDetails(contractAddress);
    }

    public JSONObject getAttackStep(String contractAddress, String attackerAddress, String spendAmount) {
        String attackStep = vulnerabilityMapper.queryAttackStep(contractAddress);
        if (attackStep == null) {
            throw new IllegalArgumentException("No data found for the given contract address.");
        }

        // 替换 0xAttackerAddress123 的值
        attackStep = attackStep.replace("0xAttackerAddress123", attackerAddress);
//        attackStep = attackStep.replace("\"balance\"", spendAmount);

        Vulnerability vulnerability = vulnerabilityMapper.queryVulnerabilityBaseInfo(contractAddress);
        if (vulnerability != null) {
            // 创建日志对象
            VulnerabilityAttackLog attackLog = new VulnerabilityAttackLog();
            attackLog.setContractName(vulnerability.getContractName());
            attackLog.setContractAddress(contractAddress);
            attackLog.setAttackerAddress(attackerAddress);
            attackLog.setAttackTime(LocalDateTime.now());
            attackLog.setVulnerabilityType(vulnerability.getVulnerabilityType());

            // 插入日志
            vulnerabilityAttackLogMapper.insert(attackLog);
        }

        // 转换为 JSONObject 返回
        JSONObject jsonObject = JSONObject.parseObject(attackStep);
        jsonObject.put("attackTime",LocalDateTime.now());
        return jsonObject;
    }

    public IPage<VulnerabilityAttackLog> getPaginatedLogs(int page, int size) {
        // 构造分页对象
        Page<VulnerabilityAttackLog> pagination = new Page<>(page, size);
        return vulnerabilityAttackLogMapper.queryPaginatedLogs(pagination);
    }

}
