package com.mix.entity;

import lombok.Getter;

@Getter
public enum VulnerabilityType {
    REENTRANCY("重入漏洞", "重入漏洞（Re-Entrance Vulnerability），是指一个合约中的函数被调用结束之前，再次执行该被调用的函数的递归调用过程。攻击者常常利用该漏洞，多次调用智能合约的相关函数，执行恶意代码；或者利用重入漏洞，绕过智能合约的安全措施，并存取访问受限数据、执行未授权的操作。例如，多次调用（受害者）智能合约执行转账操作，获取一定数额的数字资产。"),
    INTEGER_OVERFLOW("整数溢出漏洞", "整数溢出（Integer Overflow），是由于算术运算引起的，也称为算术溢出（Arithmetic Overflow）。整数溢出是一种常见错误，在其他语言中可能不会引起太多重视；但是，智能合约中的整数溢出却非常具有破坏性。智能合约对于外部用户而言是透明的，外部用户可以调用。由于以太坊（或其他区块链）的数字资产极具诱惑性，导致整数溢出也成为一种常见攻击方式。\n" +
            "整数溢出可以分为上溢下溢。每一种整数类型都有固定的表示范围。上溢是指变量在执行数值运算时，计算结果超出了整数变量的表示范围；下溢则是由于数值计算的结果非常小，小于整数变量的表示范围。\n" +
            "合约中的错误或漏洞可能会导致数百万美元、甚至千万美元的经济损失。基本的算术运算是不安全的，Solidity版本的更迭并未让整数溢问题得到显著的改善。除法运算已经变得更安全，Solidity的整数除法与纯数学中的除法不同，一方面除以一个整数会让结果变小，另一方面除以0会抛出异常。对于其他基本算术运算，加、减和乘，仍然会发生溢出问题。\n"),
    ACCESS_CONTROL("访问控制漏洞", "在以太坊的Solidity中，访问控制权限也被称为可见性修饰符（Visibility）。访问控制漏洞是指，智能合约因未正确使用访问控制权限，使得外部用户可以访问本不该被访问的数据或函数，从而查阅敏感数据或窃取数字资产。智能合约的访问控制漏洞涉及Solidity的四种访问控制修饰符（或称为访问控制权限），因使用不当而造成被修饰的数据或函数容易被其他用户查阅或调用。"),
    DOS("拒绝服务漏洞", "拒绝服务漏洞（Denial of Service，DOS）存在已久，也是智能合约的常见漏洞。在智能合约中，拒绝服务是指合约不能够按照预定的方式提供服务，这可能为合法用户带来一定的损失、甚至是非常严重的后果，这种攻击一般会持续一段时间，有的可能会导致合约永远无法提供服务。\n" +
            "攻击者通过破坏智能合约原有的程序逻辑，致使智能合约中的Ether无法取出。对智能合约的DOS攻击的方式很多，其主要目的是通过拒绝服务攻击，导致智能合约无法进行正常的交易，从而使得合约中的数字资产在一定期限内被冻结，甚至长期被冻结。\n" +
            "智能合约中的拒绝服务漏洞常见类型包括通过(Unexpected) Revert发动DOS、通过区块Gas Limit发动DOS，以及通过合约owner账户发动DOS。\n"),
    SHORT_ADDRESS("短地址漏洞", "短地址漏洞是指，利用智能合约在调用trasfer()函数时，解析ABI字符过程中遇到目标地址长度不足，即故意选择以“00”（十六进制数，一个字节）结尾的地址，并且在传入地址参数时，省略最后的“00”，导致以太坊虚拟机（EVM）在解析参数时，在参数末尾补齐“00”（一个字节）。\n" +
            "如此一来，就将需要传递的Ether数值，扩大了 (2 ** 8)倍，即相当于二进数左移8位，增加了256倍。\n"),
    TIMESTAMP_DEPENDENCY("时间戳依赖漏洞", "智能合约的执行依赖于当前区块的时间戳（Solidity中的block.timestamp和now），合约可以检索区块的时间戳，而且区块的所有交易共享同一个时间戳。区块的时间戳，则依赖于某个矿工节点，即时间戳是由矿工节点的计算机本地时间控制。如果矿工有能力稍微调整时间戳，在智能合约中错误地使用区块时间戳，将会造成严重的后果。"),
    CROSS_CONTRACT_CALL("跨合约调用漏洞", "跨合约调用漏洞（Cross-Contract Invocation Vulnerability），允许攻击者通过攻击合约直接调用被攻击合约中的某些函数。这一个漏洞可能导致智能合约被攻击者接管、数字资产被盗。\n" +
            "solidity 提供call()、delegatecall()、callcode() 函数，用于调用合约中的函数，上述函数的滥用，容易导致了潜在风险或漏洞。在开发智能合约时，对跨合约调用引发的安全问题重视还不够。这种漏洞主要由call()注入函数引发，处理不当则导致外部控制合约中call()函数相关的参数，访问合约的其他函数。\n"),
    FLASH_LOAN("闪电贷漏洞", "闪电贷（Flash Loan）是一种分布式金融（DeFi）技术，允许用户在不提供任何抵押的情况下，借用合约池中的一定数量的数字资产，但是，必须在同一笔交易（一个区块）中归还本金和利息。闪电贷的优势在于，让用户利用市场上的套利机会，实现低成本、高收益的操作。闪电贷的风险在于，如果用户无法在规定时间内还款，那么交易将被撤销，用户将损失交易费用和利息。\n" +
            "闪电贷既为用户提供了极大的便利，也成为恶意攻击的工具。通过闪电贷，攻击者利用智能合约中的漏洞，用极低的成本从支持闪电贷的合约借得大量资金，并用于漏洞攻击，以获取更大的利益。这对合约造成了巨大经济损失，也促进了DeFi生态的完善和发展，使其更加安全。\n"),
    OWNER_BACKDOOR("Owner漏洞与后门", "智能合约包含交易数据和相应的操作，只有满足要求的用户才能够查阅数据或执行操作（调用函数）。智能合约代码本身约定和解释用户的权限和义务，不同用户可以根据相应的业务需要开发智能合约。\n" +
            "然而，一些合约存在可疑的后门，具有特殊权限的用户(地址，合约的owner)，常常具有操纵用户数字资产的权限。通过预留权限，某些用户甚至任意用户的资数字资产，危害较大。\n"),
    CONSTRUCTOR("构造函数漏洞", "Solidity合约和面向对象语言相似，一般通过构造函数（constructor）初始化合约对象。Solidity合约的构造函数，是一个方法名与合约名字完全相同的函数，或者利用constructor保留字代替函数名（合约名）的一个特殊函数。创建合约时，以太网自动调用构造函数对变量进行初始化。");

    private final String name;
    private final String description;

    VulnerabilityType(String name, String description) {
        this.name = name;
        this.description = description;
    }

}
